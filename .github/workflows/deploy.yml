name: Deploy to AWS Lightsail

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_COMPOSE_FILE: docker/docker-compose.yml
  REMOTE_PROJECT_PATH: /opt/frappe-hrms

jobs:
  deploy:
    name: Deploy to Lightsail
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'eu-west-2' }}

      - name: Verify AWS CLI
        run: |
          # AWS CLI is pre-installed on GitHub Actions runners
          # For act-cli, install if needed (cached after first run)
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found, installing..."
            curl -sS "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
            rm -rf aws awscliv2.zip
            echo "‚úì AWS CLI installed"
          else
            echo "‚úì AWS CLI already available"
          fi
          aws --version

      - name: Retrieve deployment secrets from AWS Secrets Manager
        id: secrets
        run: |
          # Determine the region for the secret (can be different from default region)
          SECRET_REGION="${{ secrets.AWS_SECRETS_REGION || secrets.AWS_REGION || 'eu-west-2' }}"
          
          echo "Fetching secret from region: $SECRET_REGION"
          
          # Retrieve the secret value
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "${{ secrets.AWS_DEPLOY_SECRET_ID }}" \
            --region "$SECRET_REGION" \
            --query SecretString \
            --output text)
          
          # Export for prepare_context.py
          echo "SECRET_JSON<<EOF" >> $GITHUB_ENV
          echo "$SECRET_JSON" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Prepare deployment context
        id: prepare
        run: |
          python deploy/lightsail/prepare_context.py

      - name: Setup SSH key and test connection
        run: |
          echo "=== SSH Key Setup and Verification ==="
          
          # Ensure SSH key has correct permissions
          chmod 600 ${{ steps.prepare.outputs.ssh_key_path }}
          echo "‚úì SSH key permissions:"
          ls -la ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Verify key format
          echo ""
          echo "‚úì Verifying SSH key format..."
          head -1 ${{ steps.prepare.outputs.ssh_key_path }}
          tail -1 ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Check key type
          echo ""
          echo "‚úì Checking key type..."
          ssh-keygen -l -f ${{ steps.prepare.outputs.ssh_key_path }} || echo "Warning: Could not determine key type"
          
          # Add host to known_hosts
          echo ""
          echo "‚úì Adding host to known_hosts..."
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ steps.prepare.outputs.port }} -H ${{ steps.prepare.outputs.host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connection
          echo ""
          echo "‚úì Testing SSH connection to ${{ steps.prepare.outputs.host }}..."
          echo "  User: ${{ steps.prepare.outputs.user }}"
          echo "  Port: ${{ steps.prepare.outputs.port }}"
          echo ""
          
          if ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o IdentitiesOnly=yes \
            -o ConnectTimeout=30 \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} "echo 'SSH connection successful!'" 2>&1; then
            echo ""
            echo "‚úÖ SSH connection successful!"
          else
            echo ""
            echo "‚ùå SSH connection failed!"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the SSH key in AWS Secrets Manager matches your Lightsail key"
            echo "2. Download your Lightsail key and encode it: cat key.pem | base64 -w 0"
            echo "3. Update AWS Secrets Manager with the correct base64-encoded key"
            echo "4. Ensure the public key is in /home/ubuntu/.ssh/authorized_keys on the server"
            echo ""
            echo "Run this locally to test your key:"
            echo "  ssh -i your-key.pem ubuntu@${{ steps.prepare.outputs.host }}"
            exit 1
          fi
      
      - name: Create .env file for deployment
        run: |
          cat > deploy.env << 'EOF'
          ${{ steps.prepare.outputs.env_content }}
          EOF
          echo "Environment file created:"
          cat deploy.env
      
      - name: Copy .env file to server
        run: |
          scp -P ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            deploy.env \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }}:/tmp/frappe.env

      - name: Deploy on Lightsail instance
        run: |
          ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} << 'ENDSSH'
          
          set -e
          
          echo "=== Starting deployment ==="
          
          # Install git if not present
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            sudo apt-get update && sudo apt-get install -y git
          fi
          
          # Clone or pull the repository
          if [ -d "${{ steps.prepare.outputs.remote_path }}/.git" ]; then
            echo "=== Repository exists, pulling latest changes ==="
            cd ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} .
            git fetch origin
            git reset --hard origin/main
            git pull origin main
          else
            echo "=== Cloning repository ==="
            sudo rm -rf ${{ steps.prepare.outputs.remote_path }}
            sudo mkdir -p ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} ${{ steps.prepare.outputs.remote_path }}
            git clone https://github.com/SAH-Diagnostics/frappe-hrms.git ${{ steps.prepare.outputs.remote_path }}
            cd ${{ steps.prepare.outputs.remote_path }}
          fi
          
          echo "=== Setting up environment file ==="
          mkdir -p deploy/lightsail
          mv /tmp/frappe.env deploy/lightsail/.env.remote
          
          # Stop existing containers
          echo "=== Stopping existing containers ==="
          if [ -f "${{ steps.prepare.outputs.compose_file }}" ]; then
            sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote down || true
          fi
          
          # Pull latest images and rebuild
          echo "=== Building and starting containers ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote pull || true
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote up -d --build
          
          echo "=== Waiting for services to be ready ==="
          sleep 15
          
          # Check container status
          echo "=== Container status ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} ps
          
          # Setup nginx reverse proxy
          echo "=== Configuring nginx ==="
          
          # Check if SSL certificates exist (handle both files and symlinks)
          # Let's Encrypt uses symlinks, so check for both -f (file) and -L (symlink)
          if [ -f "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem" ] || [ -L "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem" ]; then
            # Verify the certificate is actually readable (follows symlink)
            if sudo test -r "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem"; then
              echo "‚úì SSL certificates found, configuring HTTPS"
              SSL_ENABLED=true
            else
              echo "‚ö† SSL certificate file exists but is not readable"
              SSL_ENABLED=false
            fi
          else
            echo "‚ö† SSL certificates not found"
            echo "Attempting to obtain SSL certificates using setup-ssl.sh..."

            # Ensure webroot directory exists for HTTP validation (also used by setup-ssl.sh)
            sudo mkdir -p /var/www/certbot
            sudo chown www-data:www-data /var/www/certbot

            if [ -f "deploy/lightsail/setup-ssl.sh" ]; then
              echo "Running deploy/lightsail/setup-ssl.sh with sudo"
              sudo bash deploy/lightsail/setup-ssl.sh || echo "‚úó setup-ssl.sh failed, continuing with HTTP only"
            else
              echo "‚úó deploy/lightsail/setup-ssl.sh not found, skipping automatic SSL setup"
            fi

            # Re-check if SSL certificates now exist (handle symlinks)
            if [ -f "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem" ] || [ -L "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem" ]; then
              if sudo test -r "/etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem"; then
                echo "‚úì SSL certificates obtained successfully, configuring HTTPS"
                SSL_ENABLED=true
              else
                echo "‚ö† SSL certificates exist but are not readable"
                SSL_ENABLED=false
              fi
            else
              echo "‚ö† SSL certificates still not found after attempting setup, configuring HTTP only"
              echo "To enable HTTPS manually, run on the server:"
              echo "  cd /opt/frappe-hrms/deploy/lightsail && sudo bash setup-ssl.sh"
              SSL_ENABLED=false
            fi
          fi
          
          if [ "$SSL_ENABLED" = true ]; then
            # Create nginx config with HTTPS
            sudo tee /etc/nginx/sites-available/frappe-hrms > /dev/null << 'NGINXCONF'
          upstream frappe-server {
              server 127.0.0.1:8000 fail_timeout=0;
          }

          upstream socketio-server {
              server 127.0.0.1:9000 fail_timeout=0;
          }

          # HTTP server - redirect to HTTPS
          server {
              listen 80;
              listen [::]:80;
              server_name dev-hrms.sahdiagnostics.com www.dev-hrms.sahdiagnostics.com;
              
              # Allow certbot to renew certificates
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }
              
              # Redirect all other HTTP traffic to HTTPS
              location / {
                  return 301 https://$host$request_uri;
              }
          }

          # HTTPS server
          server {
              listen 443 ssl http2;
              listen [::]:443 ssl http2;
              server_name dev-hrms.sahdiagnostics.com www.dev-hrms.sahdiagnostics.com;

              # SSL certificates managed by certbot
              ssl_certificate /etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/dev-hrms.sahdiagnostics.com/privkey.pem;
              
              # SSL configuration
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
              ssl_prefer_server_ciphers off;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;
              ssl_session_tickets off;

              # Security headers
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;

              client_max_body_size 50m;
              client_body_buffer_size 16k;
              client_body_timeout 60s;
              client_header_timeout 60s;

              # Proxy settings for Frappe
              location / {
                  proxy_pass http://frappe-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
                  proxy_set_header X-Forwarded-Port $server_port;
                  proxy_read_timeout 300;
                  proxy_connect_timeout 300;
                  proxy_send_timeout 300;
                  proxy_buffering off;
                  proxy_cache_bypass $http_upgrade;
              }

              location /socket.io {
                  proxy_pass http://socketio-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
                  proxy_read_timeout 86400;
                  proxy_send_timeout 86400;
                  proxy_buffering off;
              }

              location /assets {
                  proxy_pass http://frappe-server;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
                  proxy_cache_valid 200 60m;
                  expires 1y;
                  add_header Cache-Control "public, immutable";
              }

              location /files {
                  proxy_pass http://frappe-server;
                  proxy_http_version 1.1;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
                  proxy_read_timeout 300;
                  proxy_send_timeout 300;
              }
          }
          NGINXCONF
          else
            # Create nginx config with HTTP only (for initial setup before SSL)
            sudo tee /etc/nginx/sites-available/frappe-hrms > /dev/null << 'NGINXCONF'
          upstream frappe-server {
              server 127.0.0.1:8000 fail_timeout=0;
          }

          upstream socketio-server {
              server 127.0.0.1:9000 fail_timeout=0;
          }

          # HTTP server (temporary - run certbot to enable HTTPS)
          server {
              listen 80;
              server_name dev-hrms.sahdiagnostics.com www.dev-hrms.sahdiagnostics.com;

              client_max_body_size 50m;
              client_body_buffer_size 16k;
              
              # Allow certbot to validate domain
              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }

              location / {
                  proxy_pass http://frappe-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
                  proxy_read_timeout 300;
                  proxy_connect_timeout 300;
              }

              location /socket.io {
                  proxy_pass http://socketio-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
              }

              location /assets {
                  proxy_pass http://frappe-server;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
              }

              location /files {
                  proxy_pass http://frappe-server;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_set_header X-Forwarded-Host $host;
              }
          }
          NGINXCONF
          fi
          
          # Ensure certbot webroot directory exists
          sudo mkdir -p /var/www/certbot
          sudo chown www-data:www-data /var/www/certbot
          
          # Verify nginx config file was created
          if [ ! -f /etc/nginx/sites-available/frappe-hrms ]; then
            echo "‚úó Error: nginx config file was not created!"
            exit 1
          fi
          echo "‚úì Nginx config file created at /etc/nginx/sites-available/frappe-hrms"
          
          # Enable the site
          sudo ln -sf /etc/nginx/sites-available/frappe-hrms /etc/nginx/sites-enabled/frappe-hrms
          
          # Remove default nginx site if it exists
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Verify symlink was created
          if [ -L /etc/nginx/sites-enabled/frappe-hrms ]; then
            echo "‚úì Nginx site enabled"
          else
            echo "‚úó Error: Failed to enable nginx site"
            exit 1
          fi
          
          # Install nginx if not present
          if ! command -v nginx &> /dev/null; then
            echo "Installing nginx..."
            sudo apt-get update
            sudo apt-get install -y nginx
          fi
          
          # Test nginx configuration
          if sudo nginx -t; then
            echo "‚úì Nginx configuration is valid"
          else
            echo "‚úó Nginx configuration test failed"
            echo "Showing nginx error details:"
            sudo nginx -t 2>&1
            exit 1
          fi
          
          # Ensure nginx is running
          if ! sudo systemctl is-active --quiet nginx; then
            echo "Starting nginx service..."
            sudo systemctl start nginx
          fi
          
          # Enable nginx to start on boot
          sudo systemctl enable nginx
          
          # Reload nginx
          sudo systemctl reload nginx
          
          echo "=== Nginx configured and reloaded ==="
          
          # Verify nginx is running
          echo "=== Verifying nginx status ==="
          sudo systemctl status nginx --no-pager -l || true
          
          # Check if nginx is listening on ports 80 and 443
          echo ""
          echo "=== Checking listening ports ==="
          sudo ss -tlnp | grep -E ':80|:443' || echo "‚ö† Warning: nginx may not be listening on ports 80/443"
          
          # Verify frappe container port is accessible
          echo ""
          echo "=== Verifying frappe container connectivity ==="
          if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8000 | grep -q "200\|302\|301"; then
            echo "‚úì Frappe container is responding on port 8000"
          else
            echo "‚ö† Warning: Frappe container may not be responding on port 8000"
            echo "Checking docker container status:"
            sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} ps
          fi
          
          # Check firewall status (if ufw is installed)
          if command -v ufw &> /dev/null; then
            echo ""
            echo "=== Checking firewall status ==="
            sudo ufw status | head -10
          fi
          
          # Display SSL status
          if [ "$SSL_ENABLED" = true ]; then
            echo "‚úÖ HTTPS is ENABLED"
            echo "Site is accessible at: https://dev-hrms.sahdiagnostics.com"
          else
            echo "‚ö†Ô∏è  HTTPS is NOT ENABLED (certificates not found)"
            echo "Site is accessible at: http://dev-hrms.sahdiagnostics.com"
            echo ""
            echo "To enable HTTPS, run these commands on the server:"
            echo "  sudo apt-get install -y certbot python3-certbot-nginx"
            echo "  sudo certbot --nginx -d dev-hrms.sahdiagnostics.com -d www.dev-hrms.sahdiagnostics.com"
            echo "  sudo systemctl reload nginx"
          fi
          
          # Clean up old Docker images
          echo "=== Cleaning up old Docker images ==="
          sudo docker system prune -f
          
          echo "=== Deployment completed successfully ==="
          echo "=== Frappe HRMS should be accessible at http://${{ steps.prepare.outputs.host }} ==="
          ENDSSH

      - name: Deployment summary
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo ""
          echo "üåê Application URLs:"
          echo "   Primary: https://dev-hrms.sahdiagnostics.com"
          echo "   Fallback: http://${{ steps.prepare.outputs.host }}"
          echo ""
          echo "üì¶ Deployed to: ${{ steps.prepare.outputs.remote_path }}"
          echo ""
          echo "üîç Troubleshooting Connection Issues:"
          echo ""
          echo "If you see 'ERR_CONNECTION_REFUSED', check:"
          echo ""
          echo "1. AWS Lightsail Security Group:"
          echo "   - Go to AWS Lightsail ‚Üí Networking ‚Üí Firewall"
          echo "   - Ensure ports 80 (HTTP) and 443 (HTTPS) are open"
          echo "   - Add rules: HTTP (port 80) and HTTPS (port 443) from Anywhere (0.0.0.0/0)"
          echo ""
          echo "2. Run Diagnostic Script (SSH into server and run):"
          echo "   cd /opt/frappe-hrms"
          echo "   chmod +x deploy/lightsail/diagnose.sh"
          echo "   ./deploy/lightsail/diagnose.sh"
          echo ""
          echo "3. Manual Checks (SSH into server and run):"
          echo "   sudo systemctl status nginx"
          echo "   sudo nginx -t"
          echo "   sudo ss -tlnp | grep -E ':80|:443'"
          echo "   sudo docker compose -f /opt/frappe-hrms/docker/docker-compose.yml ps"
          echo "   curl -I http://127.0.0.1:8000"
          echo ""
          echo "‚ÑπÔ∏è  If HTTPS is not working:"
          echo "   1. SSH into the instance"
          echo "   2. Run: cd /opt/frappe-hrms/deploy/lightsail && sudo bash setup-ssl.sh"
          echo "   3. See deploy/lightsail/SSL-SETUP.md for detailed instructions"

