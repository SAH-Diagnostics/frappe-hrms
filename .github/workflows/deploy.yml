name: Deploy to AWS Lightsail

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_COMPOSE_FILE: docker/docker-compose.yml
  REMOTE_PROJECT_PATH: /opt/frappe-hrms

jobs:
  deploy:
    name: Deploy to Lightsail
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'eu-west-2' }}

      - name: Verify AWS CLI
        run: |
          # AWS CLI is pre-installed on GitHub Actions runners
          # For act-cli, install if needed (cached after first run)
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found, installing..."
            curl -sS "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
            rm -rf aws awscliv2.zip
            echo "‚úì AWS CLI installed"
          else
            echo "‚úì AWS CLI already available"
          fi
          aws --version

      - name: Retrieve deployment secrets from AWS Secrets Manager
        id: secrets
        run: |
          # Determine the region for the secret (can be different from default region)
          SECRET_REGION="${{ secrets.AWS_SECRETS_REGION || secrets.AWS_REGION || 'eu-west-2' }}"
          
          echo "Fetching secret from region: $SECRET_REGION"
          
          # Retrieve the secret value
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "${{ secrets.AWS_DEPLOY_SECRET_ID }}" \
            --region "$SECRET_REGION" \
            --query SecretString \
            --output text)
          
          # Export for prepare_context.py
          echo "SECRET_JSON<<EOF" >> $GITHUB_ENV
          echo "$SECRET_JSON" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Prepare deployment context
        id: prepare
        run: |
          python deploy/dev/prepare_context.py

      - name: Setup SSH key and test connection
        run: |
          echo "=== SSH Key Setup and Verification ==="
          
          # Ensure SSH key has correct permissions
          chmod 600 ${{ steps.prepare.outputs.ssh_key_path }}
          echo "‚úì SSH key permissions:"
          ls -la ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Verify key format
          echo ""
          echo "‚úì Verifying SSH key format..."
          head -1 ${{ steps.prepare.outputs.ssh_key_path }}
          tail -1 ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Check key type
          echo ""
          echo "‚úì Checking key type..."
          ssh-keygen -l -f ${{ steps.prepare.outputs.ssh_key_path }} || echo "Warning: Could not determine key type"
          
          # Add host to known_hosts
          echo ""
          echo "‚úì Adding host to known_hosts..."
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ steps.prepare.outputs.port }} -H ${{ steps.prepare.outputs.host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connection
          echo ""
          echo "‚úì Testing SSH connection to ${{ steps.prepare.outputs.host }}..."
          echo "  User: ${{ steps.prepare.outputs.user }}"
          echo "  Port: ${{ steps.prepare.outputs.port }}"
          echo ""
          
          if ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o IdentitiesOnly=yes \
            -o ConnectTimeout=30 \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} "echo 'SSH connection successful!'" 2>&1; then
            echo ""
            echo "‚úÖ SSH connection successful!"
          else
            echo ""
            echo "‚ùå SSH connection failed!"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the SSH key in AWS Secrets Manager matches your Lightsail key"
            echo "2. Download your Lightsail key and encode it: cat key.pem | base64 -w 0"
            echo "3. Update AWS Secrets Manager with the correct base64-encoded key"
            echo "4. Ensure the public key is in /home/ubuntu/.ssh/authorized_keys on the server"
            echo ""
            echo "Run this locally to test your key:"
            echo "  ssh -i your-key.pem ubuntu@${{ steps.prepare.outputs.host }}"
            exit 1
          fi
      
      - name: Create .env file for deployment
        run: |
          cat > deploy.env << 'EOF'
          ${{ steps.prepare.outputs.env_content }}
          EOF
          echo "Environment file created:"
          cat deploy.env
      
      - name: Copy .env file to server
        run: |
          scp -P ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            deploy.env \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }}:/tmp/frappe.env

      - name: Deploy on Lightsail instance
        run: |
          ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} << 'ENDSSH'
          
          set -e
          
          echo "=== Starting deployment ==="
          
          # Install git if not present
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            sudo apt-get update && sudo apt-get install -y git
          fi
          
          # Clone or pull the repository
          if [ -d "${{ steps.prepare.outputs.remote_path }}/.git" ]; then
            echo "=== Repository exists, pulling latest changes ==="
            cd ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} .
            git fetch origin
            git reset --hard origin/main
            git pull origin main
          else
            echo "=== Cloning repository ==="
            sudo rm -rf ${{ steps.prepare.outputs.remote_path }}
            sudo mkdir -p ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} ${{ steps.prepare.outputs.remote_path }}
            git clone https://github.com/SAH-Diagnostics/frappe-hrms.git ${{ steps.prepare.outputs.remote_path }}
            cd ${{ steps.prepare.outputs.remote_path }}
          fi
          
          echo "=== Setting up environment file ==="
          mkdir -p deploy/dev
          mv /tmp/frappe.env deploy/dev/.env.remote
          
          # Stop existing containers
          echo "=== Stopping existing containers ==="
          if [ -f "${{ steps.prepare.outputs.compose_file }}" ]; then
            sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/dev/.env.remote down || true
          fi
          
          # Pull latest images and rebuild
          echo "=== Building and starting containers ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/dev/.env.remote pull || true
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/dev/.env.remote up -d --build
          
          echo "=== Waiting for services to be ready ==="
          sleep 15
          
          # Check container status
          echo "=== Container status ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} ps
          
          # Setup nginx reverse proxy and SSL certificates
          echo "=== Configuring nginx and SSL certificates ==="
          
          # Install nginx if not present
          if ! command -v nginx &> /dev/null; then
            echo "Installing nginx..."
            sudo apt-get update
            sudo apt-get install -y nginx
          fi
          
          # Install certbot if not present
          if ! command -v certbot &> /dev/null; then
            echo "Installing certbot..."
            sudo apt-get update
            sudo apt-get install -y certbot python3-certbot-nginx
          fi
          
          # Ensure certbot webroot directory exists
          sudo mkdir -p /var/www/certbot
          sudo chown www-data:www-data /var/www/certbot
          
          # Domain configuration
          DOMAIN="dev-hrms.sahdiagnostics.com"
          WWW_DOMAIN="www.dev-hrms.sahdiagnostics.com"
          CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"
          KEY_PATH="/etc/letsencrypt/live/$DOMAIN/privkey.pem"
          
          # Function to check if certificate is valid and not expired
          check_certificate_valid() {
            if [ ! -f "$CERT_PATH" ] && [ ! -L "$CERT_PATH" ]; then
              return 1
            fi
            
            if ! sudo test -r "$CERT_PATH" || ! sudo test -r "$KEY_PATH"; then
              return 1
            fi
            
            # Check if certificate is expired or expires within 30 days
            # Using openssl to check expiration (returns 0 if valid, 1 if expired/expiring soon)
            if sudo openssl x509 -checkend 2592000 -noout -in "$CERT_PATH" 2>/dev/null; then
              return 0
            else
              return 1
            fi
          }
          
          # Check certificate status and obtain/renew if needed
          CERT_NEEDED=false
          if check_certificate_valid; then
            echo "‚úì SSL certificate exists and is valid"
            CERT_EXPIRY=$(sudo openssl x509 -enddate -noout -in "$CERT_PATH" 2>/dev/null | cut -d= -f2)
            echo "  Certificate expires: $CERT_EXPIRY"
          else
            echo "‚ö† SSL certificate is missing, expired, or expiring soon"
            CERT_NEEDED=true
          fi
          
          # Deploy nginx config first (needed for certbot webroot validation)
          echo "=== Deploying nginx configuration ==="
          if [ ! -f "deploy/dev/nginx.conf" ]; then
            echo "‚úó Error: deploy/dev/nginx.conf not found!"
            exit 1
          fi
          
          # Copy nginx config to system location
          sudo cp deploy/dev/nginx.conf /etc/nginx/sites-available/frappe-hrms
          
          # Enable the site
          sudo ln -sf /etc/nginx/sites-available/frappe-hrms /etc/nginx/sites-enabled/frappe-hrms
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Start nginx if not running (needed for certbot webroot validation)
          if ! sudo systemctl is-active --quiet nginx; then
            echo "Starting nginx for certificate validation..."
            sudo systemctl start nginx
          else
            # Test nginx config before reloading
            if sudo nginx -t; then
              sudo systemctl reload nginx
            else
              echo "‚ö† Nginx config test failed, but continuing for certificate setup"
            fi
          fi
          
          # Obtain or renew SSL certificate
          if [ "$CERT_NEEDED" = true ]; then
            echo "=== Obtaining SSL certificate ==="
            
            # Use certbot webroot method (works even if nginx is running)
            sudo certbot certonly --webroot \
              -w /var/www/certbot \
              -d "$DOMAIN" \
              -d "$WWW_DOMAIN" \
              --non-interactive \
              --agree-tos \
              --email admin@sahdiagnostics.com \
              --keep-until-expiring || {
              
              echo "‚ö† Certbot webroot method failed, trying standalone method..."
              # Stop nginx temporarily for standalone mode
              sudo systemctl stop nginx
              sudo certbot certonly --standalone \
                -d "$DOMAIN" \
                -d "$WWW_DOMAIN" \
                --non-interactive \
                --agree-tos \
                --email admin@sahdiagnostics.com
              # Restart nginx
              sudo systemctl start nginx
            }
            
            # Verify certificate was obtained
            if check_certificate_valid; then
              echo "‚úì SSL certificate obtained successfully"
              CERT_EXPIRY=$(sudo openssl x509 -enddate -noout -in "$CERT_PATH" 2>/dev/null | cut -d= -f2)
              echo "  Certificate expires: $CERT_EXPIRY"
            else
              echo "‚úó Error: Failed to obtain valid SSL certificate"
              echo "  Continuing with deployment, but HTTPS may not work"
            fi
          else
            # Certificate exists and is valid, but try to renew if close to expiration
            echo "=== Checking if certificate renewal is needed ==="
            # Renew if certificate expires within 30 days
            if ! sudo openssl x509 -checkend 2592000 -noout -in "$CERT_PATH" 2>/dev/null; then
              echo "Certificate expires soon, attempting renewal..."
              sudo certbot renew --quiet --nginx || {
                echo "‚ö† Certificate renewal failed, but existing certificate is still valid"
              }
            fi
          fi
          
          # Set up automatic certificate renewal cron job
          echo "=== Setting up automatic certificate renewal ==="
          CRON_JOB="0 0,12 * * * /usr/bin/certbot renew --quiet --nginx && /usr/bin/systemctl reload nginx"
          if ! sudo crontab -l 2>/dev/null | grep -q "certbot renew"; then
            (sudo crontab -l 2>/dev/null; echo "$CRON_JOB") | sudo crontab -
            echo "‚úì Certbot renewal cron job added"
          else
            echo "‚úì Certbot renewal cron job already exists"
          fi
          
          # Final nginx configuration test and reload
          echo "=== Final nginx configuration ==="
          if sudo nginx -t; then
            echo "‚úì Nginx configuration is valid"
            sudo systemctl reload nginx
          else
            echo "‚úó Nginx configuration test failed"
            echo "Showing nginx error details:"
            sudo nginx -t 2>&1
            exit 1
          fi
          
          # Enable nginx to start on boot
          sudo systemctl enable nginx
          
          # Verify nginx config file was created
          if [ ! -f /etc/nginx/sites-available/frappe-hrms ]; then
            echo "‚úó Error: nginx config file was not created!"
            exit 1
          fi
          echo "‚úì Nginx config file deployed from deploy/dev/nginx.conf"
          
          # Verify symlink was created
          if [ -L /etc/nginx/sites-enabled/frappe-hrms ]; then
            echo "‚úì Nginx site enabled"
          else
            echo "‚úó Error: Failed to enable nginx site"
            exit 1
          fi
          
          echo "=== Nginx configured and reloaded ==="
          
          # Verify nginx is running
          echo "=== Verifying nginx status ==="
          sudo systemctl status nginx --no-pager -l || true
          
          # Check if nginx is listening on ports 80 and 443
          echo ""
          echo "=== Checking listening ports ==="
          sudo ss -tlnp | grep -E ':80|:443' || echo "‚ö† Warning: nginx may not be listening on ports 80/443"
          
          # Verify frappe container port is accessible
          echo ""
          echo "=== Verifying frappe container connectivity ==="
          if curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8000 | grep -q "200\|302\|301"; then
            echo "‚úì Frappe container is responding on port 8000"
          else
            echo "‚ö† Warning: Frappe container may not be responding on port 8000"
            echo "Checking docker container status:"
            sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} ps
          fi
          
          # Check firewall status (if ufw is installed)
          if command -v ufw &> /dev/null; then
            echo ""
            echo "=== Checking firewall status ==="
            sudo ufw status | head -10
          fi
          
          echo "=== Ensuring AWS CLI is available inside frappe container for backups ==="
          if ! sudo docker exec docker-frappe-1 bash -lc "command -v aws >/dev/null 2>&1"; then
            sudo docker exec docker-frappe-1 bash -lc "sudo apt-get update && sudo apt-get install -y awscli"
          fi

          echo "=== Ensuring file backup cron job is configured ==="
          # Make backup script executable
          if [ -f "${{ steps.prepare.outputs.remote_path }}/scripts/sync-files-to-s3.sh" ]; then
            sudo chmod +x "${{ steps.prepare.outputs.remote_path }}/scripts/sync-files-to-s3.sh"
          fi

          # Read backup interval (in hours) from the env file created during deploy
          BACKUP_ENV_FILE="${{ steps.prepare.outputs.remote_path }}/deploy/dev/.env.remote"
          BACKUP_HOURS="24"
          if [ -f "$BACKUP_ENV_FILE" ]; then
            VALUE=$(grep -E '^FILES_BACK_UP_HOURS=' "$BACKUP_ENV_FILE" | cut -d= -f2 | tr -d '\r')
            if [ -n "$VALUE" ]; then
              BACKUP_HOURS="$VALUE"
            fi
          fi

          # Build cron schedule: run at minute 0 every BACKUP_HOURS
          CRON_SCHEDULE="0 */$BACKUP_HOURS * * *"
          CRON_JOB="$CRON_SCHEDULE ${{ steps.prepare.outputs.remote_path }}/scripts/sync-files-to-s3.sh >> /var/log/frappe-files-sync.log 2>&1"

          # Ensure only one cron entry for the backup script
          (sudo crontab -l 2>/dev/null | grep -v 'sync-files-to-s3.sh' ; echo "$CRON_JOB") | sudo crontab -

          # Display SSL status
          if check_certificate_valid; then
            CERT_EXPIRY=$(sudo openssl x509 -enddate -noout -in "$CERT_PATH" 2>/dev/null | cut -d= -f2)
            echo ""
            echo "‚úÖ HTTPS is ENABLED"
            echo "Site is accessible at: https://dev-hrms.sahdiagnostics.com"
            echo "Certificate expires: $CERT_EXPIRY"
            echo "HTTP traffic will be automatically redirected to HTTPS"
          else
            echo ""
            echo "‚ö†Ô∏è  HTTPS certificate is missing or invalid"
            echo "Site may be accessible at: http://dev-hrms.sahdiagnostics.com"
            echo "Certificate setup may have failed - check logs above"
          fi
          
          # Clean up old Docker images
          echo "=== Cleaning up old Docker images ==="
          sudo docker system prune -f
          
          echo "=== Deployment completed successfully ==="
          echo "=== Frappe HRMS should be accessible at http://${{ steps.prepare.outputs.host }} ==="
          ENDSSH

      - name: Deployment summary
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo ""
          echo "üåê Application URLs:"
          echo "   Primary: https://dev-hrms.sahdiagnostics.com"
          echo "   Fallback: http://${{ steps.prepare.outputs.host }}"
          echo ""
          echo "üì¶ Deployed to: ${{ steps.prepare.outputs.remote_path }}"
          echo ""
          echo "üîç Troubleshooting Connection Issues:"
          echo ""
          echo "If you see 'ERR_CONNECTION_REFUSED', check:"
          echo ""
          echo "1. AWS Lightsail Security Group:"
          echo "   - Go to AWS Lightsail ‚Üí Networking ‚Üí Firewall"
          echo "   - Ensure ports 80 (HTTP) and 443 (HTTPS) are open"
          echo "   - Add rules: HTTP (port 80) and HTTPS (port 443) from Anywhere (0.0.0.0/0)"
          echo ""
          echo "2. Manual Checks (SSH into server and run):"
          echo "   sudo systemctl status nginx"
          echo "   sudo nginx -t"
          echo "   sudo ss -tlnp | grep -E ':80|:443'"
          echo "   sudo docker compose -f /opt/frappe-hrms/docker/docker-compose.yml ps"
          echo "   curl -I http://127.0.0.1:8000"
          echo ""
          echo "‚ÑπÔ∏è  If HTTPS is not working:"
          echo "   1. Check certificate status: sudo certbot certificates"
          echo "   2. Manually renew if needed: sudo certbot renew --nginx"
          echo "   3. Check nginx logs: sudo tail -f /var/log/nginx/error.log"

