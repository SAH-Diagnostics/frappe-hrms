name: Deploy to AWS Lightsail

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_COMPOSE_FILE: docker/docker-compose.yml
  REMOTE_PROJECT_PATH: /opt/frappe-hrms

jobs:
  deploy:
    name: Deploy to Lightsail
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'eu-west-2' }}

      - name: Verify AWS CLI
        run: |
          # AWS CLI is pre-installed on GitHub Actions runners
          # For act-cli, install if needed (cached after first run)
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found, installing..."
            curl -sS "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
            rm -rf aws awscliv2.zip
            echo "âœ“ AWS CLI installed"
          else
            echo "âœ“ AWS CLI already available"
          fi
          aws --version

      - name: Retrieve deployment secrets from AWS Secrets Manager
        id: secrets
        run: |
          # Determine the region for the secret (can be different from default region)
          SECRET_REGION="${{ secrets.AWS_SECRETS_REGION || secrets.AWS_REGION || 'eu-west-2' }}"
          
          echo "Fetching secret from region: $SECRET_REGION"
          
          # Retrieve the secret value
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "${{ secrets.AWS_DEPLOY_SECRET_ID }}" \
            --region "$SECRET_REGION" \
            --query SecretString \
            --output text)
          
          # Export for prepare_context.py
          echo "SECRET_JSON<<EOF" >> $GITHUB_ENV
          echo "$SECRET_JSON" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Prepare deployment context
        id: prepare
        run: |
          python deploy/lightsail/prepare_context.py

      - name: Setup SSH key and test connection
        run: |
          echo "=== SSH Key Setup and Verification ==="
          
          # Ensure SSH key has correct permissions
          chmod 600 ${{ steps.prepare.outputs.ssh_key_path }}
          echo "âœ“ SSH key permissions:"
          ls -la ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Verify key format
          echo ""
          echo "âœ“ Verifying SSH key format..."
          head -1 ${{ steps.prepare.outputs.ssh_key_path }}
          tail -1 ${{ steps.prepare.outputs.ssh_key_path }}
          
          # Check key type
          echo ""
          echo "âœ“ Checking key type..."
          ssh-keygen -l -f ${{ steps.prepare.outputs.ssh_key_path }} || echo "Warning: Could not determine key type"
          
          # Add host to known_hosts
          echo ""
          echo "âœ“ Adding host to known_hosts..."
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ steps.prepare.outputs.port }} -H ${{ steps.prepare.outputs.host }} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connection
          echo ""
          echo "âœ“ Testing SSH connection to ${{ steps.prepare.outputs.host }}..."
          echo "  User: ${{ steps.prepare.outputs.user }}"
          echo "  Port: ${{ steps.prepare.outputs.port }}"
          echo ""
          
          if ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o IdentitiesOnly=yes \
            -o ConnectTimeout=30 \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} "echo 'SSH connection successful!'" 2>&1; then
            echo ""
            echo "âœ… SSH connection successful!"
          else
            echo ""
            echo "âŒ SSH connection failed!"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the SSH key in AWS Secrets Manager matches your Lightsail key"
            echo "2. Download your Lightsail key and encode it: cat key.pem | base64 -w 0"
            echo "3. Update AWS Secrets Manager with the correct base64-encoded key"
            echo "4. Ensure the public key is in /home/ubuntu/.ssh/authorized_keys on the server"
            echo ""
            echo "Run this locally to test your key:"
            echo "  ssh -i your-key.pem ubuntu@${{ steps.prepare.outputs.host }}"
            exit 1
          fi
      
      - name: Create .env file for deployment
        run: |
          cat > deploy.env << 'EOF'
          ${{ steps.prepare.outputs.env_content }}
          EOF
          echo "Environment file created:"
          cat deploy.env
      
      - name: Copy .env file to server
        run: |
          scp -P ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            deploy.env \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }}:/tmp/frappe.env

      - name: Deploy on Lightsail instance
        run: |
          ssh -p ${{ steps.prepare.outputs.port }} \
            -i ${{ steps.prepare.outputs.ssh_key_path }} \
            -o StrictHostKeyChecking=no \
            -o IdentitiesOnly=yes \
            ${{ steps.prepare.outputs.user }}@${{ steps.prepare.outputs.host }} << 'ENDSSH'
          
          set -e
          
          echo "=== Starting deployment ==="
          
          # Install git if not present
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            sudo apt-get update && sudo apt-get install -y git
          fi
          
          # Clone or pull the repository
          if [ -d "${{ steps.prepare.outputs.remote_path }}/.git" ]; then
            echo "=== Repository exists, pulling latest changes ==="
            cd ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} .
            git fetch origin
            git reset --hard origin/main
            git pull origin main
          else
            echo "=== Cloning repository ==="
            sudo rm -rf ${{ steps.prepare.outputs.remote_path }}
            git clone https://github.com/SAH-Diagnostics/frappe-hrms.git ${{ steps.prepare.outputs.remote_path }}
            cd ${{ steps.prepare.outputs.remote_path }}
            sudo chown -R ${{ steps.prepare.outputs.user }}:${{ steps.prepare.outputs.user }} .
          fi
          
          echo "=== Setting up environment file ==="
          mkdir -p deploy/lightsail
          mv /tmp/frappe.env deploy/lightsail/.env.remote
          
          # Stop existing containers
          echo "=== Stopping existing containers ==="
          if [ -f "${{ steps.prepare.outputs.compose_file }}" ]; then
            sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote down || true
          fi
          
          # Pull latest images and rebuild
          echo "=== Building and starting containers ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote pull || true
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} --env-file deploy/lightsail/.env.remote up -d --build
          
          echo "=== Waiting for services to be ready ==="
          sleep 15
          
          # Check container status
          echo "=== Container status ==="
          sudo docker compose -f ${{ steps.prepare.outputs.compose_file }} ps
          
          # Setup nginx reverse proxy
          echo "=== Configuring nginx ==="
          sudo tee /etc/nginx/sites-available/frappe-hrms > /dev/null << 'NGINXCONF'
          upstream frappe-server {
              server 127.0.0.1:8000 fail_timeout=0;
          }

          upstream socketio-server {
              server 127.0.0.1:9000 fail_timeout=0;
          }

          server {
              listen 80;
              server_name _;

              client_max_body_size 50m;
              client_body_buffer_size 16k;

              location / {
                  proxy_pass http://frappe-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_read_timeout 300;
                  proxy_connect_timeout 300;
              }

              location /socket.io {
                  proxy_pass http://socketio-server;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              location /assets {
                  proxy_pass http://frappe-server;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              location /files {
                  proxy_pass http://frappe-server;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }
          NGINXCONF
          
          # Enable the site
          sudo ln -sf /etc/nginx/sites-available/frappe-hrms /etc/nginx/sites-enabled/frappe-hrms
          
          # Remove default nginx site if it exists
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Test nginx configuration
          sudo nginx -t
          
          # Reload nginx
          sudo systemctl reload nginx
          
          echo "=== Nginx configured and reloaded ==="
          
          # Clean up old Docker images
          echo "=== Cleaning up old Docker images ==="
          sudo docker system prune -f
          
          echo "=== Deployment completed successfully ==="
          echo "=== Frappe HRMS should be accessible at http://${{ steps.prepare.outputs.host }} ==="
          ENDSSH

      - name: Deployment summary
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ Access your application at: http://${{ steps.prepare.outputs.host }}"
          echo "ðŸ“¦ Deployed to: ${{ steps.prepare.outputs.remote_path }}"

